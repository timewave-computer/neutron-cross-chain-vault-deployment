#![no_std]
extern crate alloc;

use alloc::{format, string::ToString as _, vec, vec::Vec};
use alloy_primitives::U256;
use alloy_rpc_types_eth::EIP1186AccountProofResponse;
use alloy_sol_types::SolValue;
use clearing_queue_core::{VAULT_ADDRESS, WithdrawRequest};
use serde_json::{Value, json};
use valence_coprocessor::{StateProof, Witness};
use valence_coprocessor_wasm::abi;

const NETWORK: &str = "eth-mainnet";
const DOMAIN: &str = "ethereum-alpha";

/// Fn selector defined as Keccak256("withdrawRequests(uint64)")[..4]
const FN_SELECTOR: &[u8] = &[0x94, 0xba, 0x2b, 0x8d];

/// slot value of the storageLayout of the ABI. Can be obtained via foundry.
/// Note: the actual storage slot is -1 of the one generated by foundry.
// TODO automate the generation of this constant
const WITHDRAWS_MAPPING_SLOT: u64 = 0x9;

pub fn get_witnesses(args: Value) -> anyhow::Result<Vec<Witness>> {
    let block =
        abi::get_latest_block(DOMAIN)?.ok_or_else(|| anyhow::anyhow!("no valid domain block"))?;

    let root = block.root;
    let block = format!("0x{:x}", block.number);

    let withdraw_request_id = args["withdraw_request_id"].as_u64().unwrap();

    let encoded = (withdraw_request_id).abi_encode();
    let encoded = [FN_SELECTOR, &encoded].concat();
    let encoded = hex::encode(encoded);
    let encoded = ["0x", encoded.as_str()].concat();

    let data = abi::alchemy(
        NETWORK,
        "eth_call",
        &json!(
            [
                {
                    "to": VAULT_ADDRESS,
                    "data": encoded,
                },
                block,
            ]
        ),
    )?;

    abi::log!(
        "received an eth_call response: {}",
        serde_json::to_string(&data).unwrap_or_default()
    )?;

    let data = data
        .as_str()
        .and_then(|d| d.strip_prefix("0x"))
        .ok_or_else(|| anyhow::anyhow!("invalid response"))?;

    let data = hex::decode(data).map_err(|e| anyhow::anyhow!("invalid response hex: {e}"))?;
    let withdraw = WithdrawRequest::try_from_eth_call(&data)?;

    let id = U256::from(withdraw_request_id).to_be_bytes::<32>();
    let slot = U256::from(WITHDRAWS_MAPPING_SLOT).to_be_bytes::<32>();
    let slot = [id, slot].concat();
    let slot = alloy_primitives::keccak256(slot);

    let slot_id_owner = U256::from_be_slice(slot.as_slice());
    let slot_redemption_rate = slot_id_owner + U256::from(1);
    let slot_shares_amount = slot_id_owner + U256::from(2);
    let slot_receiver_pointer = slot_id_owner + U256::from(3);

    let mut storage_keys_to_prove = vec![
        slot_id_owner,
        slot_redemption_rate,
        slot_shares_amount,
        slot_receiver_pointer,
    ];

    let receiver_slots = if withdraw.receiver.len() < 32 {
        0
    } else {
        withdraw.receiver.len().div_ceil(32)
    } as u64;

    let slot = alloy_primitives::keccak256(slot_receiver_pointer.to_be_bytes::<32>());
    let slot = U256::from_be_slice(slot.as_slice());
    for i in 0..receiver_slots {
        storage_keys_to_prove.push(slot + U256::from(i));
    }

    let proof = abi::alchemy(
        NETWORK,
        "eth_getProof",
        &json!([VAULT_ADDRESS, storage_keys_to_prove, block]),
    )?;

    let proof: EIP1186AccountProofResponse = serde_json::from_value(proof)?;

    abi::log!(
        "{}",
        serde_json::to_string(&json!({
            "withdraw": withdraw,
            "account": VAULT_ADDRESS,
            "proof": proof,
            "block": block,
            "root": format!("0x{}", hex::encode(root)),
        }))
        .unwrap_or_default()
    )?;

    let proof = bincode::serde::encode_to_vec(proof, bincode::config::standard())?;
    let withdraw = bincode::serde::encode_to_vec(withdraw, bincode::config::standard())?;

    let proof = Witness::StateProof(StateProof {
        domain: DOMAIN.into(),
        root,
        payload: Default::default(),
        proof,
    });
    let withdraw = Witness::Data(withdraw);

    Ok(vec![proof, withdraw])
}

pub fn entrypoint(args: Value) -> anyhow::Result<Value> {
    abi::log!(
        "received an entrypoint request with arguments {}",
        serde_json::to_string(&args).unwrap_or_default()
    )?;

    let cmd = args["payload"]["cmd"].as_str().unwrap();

    match cmd {
        "store" => {
            let path = args["payload"]["path"].as_str().unwrap().to_string();
            let bytes = serde_json::to_vec(&args).unwrap();

            abi::set_storage_file(&path, &bytes).unwrap();
        }

        _ => panic!("unknown entrypoint command"),
    }

    Ok(args)
}
